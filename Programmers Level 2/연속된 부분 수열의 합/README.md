# 연속된 부분 수열의 합 (프로그래머스)

https://school.programmers.co.kr/learn/courses/30/lessons/178870

# 문제 설명

비내림차순으로 정렬된 수열이 주어질 때, 다음 조건을 만족하는 부분 수열을 찾으려고 합니다.

기존 수열에서 임의의 두 인덱스의 원소와 그 사이의 원소를 모두 포함하는 부분 수열이어야 합니다.
부분 수열의 합은 k입니다.

합이 k인 부분 수열이 여러 개인 경우 길이가 짧은 수열을 찾습니다.

길이가 짧은 수열이 여러 개인 경우 앞쪽(시작 인덱스가 작은)에 나오는 수열을 찾습니다.

수열을 나타내는 정수 배열 sequence와 부분 수열의 합을 나타내는 정수 k가 매개변수로 주어질 때,

위 조건을 만족하는 부분 수열의 시작 인덱스와 마지막 인덱스를 배열에 담아 return 하는 solution 함수를 완성해주세요.

이때 수열의 인덱스는 0부터 시작합니다.

# 제한 조건

5 ≤ sequence의 길이 ≤ 1,000,000

1 ≤ sequence의 원소 ≤ 1,000

sequence는 비내림차순으로 정렬되어 있습니다.

5 ≤ k ≤ 1,000,000,000

k는 항상 sequence의 부분 수열로 만들 수 있는 값입니다.

# 풀이

반복문 2개를 사용하여 해결 할 수 있지만 시간제한에 걸립니다

따라서 포인터2개를 이용하여 1번의 반복문으로(O(N)) 해결해야합니다

1개의 수열로 찾고자 하는 값K와 일치한다면 그 인덱스값이 가장 짧은 길이의 수열이 됩니다

따라서 if문을 사용하여 sequence[sequence.length] === k 와 sequence[0] === k 일때 각각 얼리리턴을 합니다

sum 변수와 앞쪽 인덱스를 가리키는 변수 front(인덱스 0), 앞쪽 인덱스보다 앞을 가리키는 변수 back(인덱스 1) 각각 선언합니다

그리고서 while문으로 sequence배열을 순환하며

sum값보다 k값이 클때 back++와 sum += sequence[back]를 하여 sum값과 back 포인터값을 증가시킵니다

반대일 경우 sum -= sequence[front] 와 front++;를 하여 현재 front값을 sum에서 빼고 front값을 증가시킵니다

이러한 방법으로 2개의 포인터를 이용하여 해결 할 수 있습니다
